#!/usr/bin/env python3

import argparse
import atexit
import ipaddress
import os
import subprocess
import sys
import textwrap
from collections import OrderedDict

from fuse import FUSE

from basefs.fs import FileSystem
from basefs.keys import Key
from basefs.logs import Log


mount_parser = argparse.ArgumentParser(description='Mount an existing filesystem', prog='basefs mount')
mount_parser.add_argument('logpath')
mount_parser.add_argument('mountpoint')
mount_parser.add_argument('-k', '--key', dest='keypath', nargs=1,
    help='Path to the EC private key. use genkey for creating one')
mount_parser.add_argument('--fs-handler', dest='handler', nargs=1,
    help='Custom handler script for filesystem update notifications')
mount_parser.add_argument('-d', '--debug', dest='debug', action='store_true',
    help='Enables debugging information.')


def mount():
    args = mount_parser.parse_args()
    logpath = args.logpath
    key = args.keypath[0]
    mountpoint = args.mountpoint
    if not os.path.exists(mountpoint):
        sys.stderr.write("Error: mountpoint %s does not exist.\n" % mountpoint)
        sys.exit(4)
    context = {
        'script': os.path.realpath(__file__),
        'log': logpath,
        'handler': '--fs-handler'+args.handler[0] if args.handler else '',
        'debug': '--log-level=debug' if args.debug else ''
    }
    cmd = "serf agent --event-handler='%(script)s handler %(log)s %(handler)s' %(debug)s" % context
    sys.stdout.write(cmd + '\n')
    serf_agent = subprocess.Popen(cmd, shell=True)
    
    atexit.register(lambda: serf_agent.kill())
    FUSE(FileSystem(logpath, key), mountpoint, nothreads=True, foreground=True)


bootstrap_parser = argparse.ArgumentParser(
    description='Creates a new filesystem by generating a log file containing all the necessary information',
    prog='basefs bootstrap')
bootstrap_parser.add_argument('logpath')
bootstrap_parser.add_argument('-k', '--keys', dest='keypaths', nargs=1,
    help='Comma separated list of paths containing the root keys.')
bootstrap_parser.add_argument('-i', '--ips', dest='ips', nargs=1,
    help='comma separated ips used as boostrapping nodes.')
bootstrap_parser.add_argument('-f', '--force', dest='force', action='store_true',
    help='Rewrite log file if present')


def bootstrap():
    args = bootstrap_parser.parse_args()
    logpath = args.logpath
    if os.path.exists(logpath):
        if not args.force:
            sys.stderr.write("Error: logpath %s already exists and --force argument was not provided\n" % logpath)
            sys.exit(1)
        else:
            os.remove(logpath)
    if not args.keypaths:
        sys.stderr.write("Error: missing bootstraping keypath\n")
        sys.exit(1)
    if not args.ips:
        sys.stderr.write("Error: missing bootstraping ip\n")
        sys.exit(1)
    keys = [Key.load(keypath) for keypath in args.keypaths[0].split(',')]
    ips = [str(ipaddress.ip_address(ip)) for ip in args.ips[0].split(',')]
    log = Log(logpath)
    log.bootstrap(keys, ips)
    sys.exit(0)


handler_parser = argparse.ArgumentParser(description='Run as Serf handler', prog='basefs handler')
handler_parser.add_argument('logpath')
handler_parser.add_argument('--fs-handler', dest='handler', nargs=1,
    help='custom handler, used for executing custom actions when a path is updated.')


def handler():
    args = handler_parser.parse_args()
    handler = args.handler[0] if args.handler else None
    if handler:
        if not os.path.isfile(handler):
            sys.stderr.write("Error: fs handler %s does not exist or is not a file\n" % handler)
            sys.exit(2)
        elif not os.access(handler, os.X_OK):
            sys.stderr.write("Error: fs handler %s has no execution permissions\n" % handler)
            sys.exit(3)
    event = os.environ.get('SERF_EVENT')
    user_event = os.environ.get('SERF_USER_EVENT')
    if event == 'user' and user_event == 'logentry':
        # TODO while read line: zlib.decompres(lines)
        line = sys.stdin.readline().strip()
        try:
            entry = LogEntry.read_line(line)
            entry.clean()
        except Exception as err:
            sys.stdout.write("Invalid log entry '%s', %s\n" % (line, err))
            sys.exit(2)
        context = {
            'id': line.split()[0],
            'logpath': args.logpath,
            'line': line,
            'handler': handler,
            'path': entry.path,
        }
        exit_code = os.system("grep '^%(id)s ' %(logpath)s > /dev/null && exit 99 || echo '%(line)s' >> %(logpath)s;" % context)
        if exit_code == 99:
            sys.stdout.write('%(id)s already present\n' % context)
        elif exit_code == 0:
            sys.stdout.write('OK: %(id)s not present\n' % context)
            if args.handler:
                os.system("%(handler)s %(path)s")
        else:
            sys.stdout.write('%(id)s shell error writing to log\n' % context)
    sys.exit()


genkey_parser = argparse.ArgumentParser(description='Generate a new EC private key', prog='basefs genkey')
genkey_parser.add_argument('keypath')

def genkey():
    args = genkey_parser.parse_args()
    key = Key.generate()
    key.save(args.keypath)
    sys.exit()


def help():
    commands = []
    for key, value in methods.items():
        method, parser = value
        commands.append('    '+key + ('\t' + parser.description if parser else ''))
    sys.stdout.write(textwrap.dedent("""\
        Usage: basefs COMMAND [arg...]
               basefs [ --help | -v | --version ]
        
        Basically Available, Soft state, Eventually consistent File System.
        
        Commands:
        %s
        
        Run 'basefs COMMAND --help' for more information on a command
        """) % '\n'.join(commands))
    sys.exit()


methods = OrderedDict([
    ('mount', (mount, mount_parser)),
    ('handler', (handler, handler_parser)),
    ('bootstrap', (bootstrap, bootstrap_parser)),
    ('genkey', (genkey, genkey_parser)),
    ('help', (help, None)),
])


if __name__ == '__main__':
    if len(sys.argv) > 1:
        method = sys.argv.pop(1)
        if method == '--help':
            method = 'help'
        try:
            method = methods[method][0]
        except KeyError:
            sys.stdout.write("Error: not recognized argument %s\n" % method)
            help()
            sys.exit(1)
    else:
        sys.stdout.write("Error: missing arguments\n")
        help()
        sys.exit(1)
    method()
