#!/usr/bin/env python3

import argparse
import atexit
import configparser
import datetime
import functools
import hashlib
import ipaddress
import logging
import os
import platform
import pwd
import signal
import socket
import stat
import subprocess
import sys
import textwrap
import threading
import time
import urllib.request
import uuid
import zipfile
from collections import OrderedDict

from basefs import utils, validators

try:
    from fuse import FUSE
    
    from basefs import loop, exceptions, gossip
    from basefs.fs import FileSystem
    from basefs.keys import Key
    from basefs.logs import Log
    from basefs.state import BlockState
    from basefs.views import View
except ImportError:
    if sys.argv[1] != 'installserf':
        raise


basefs_dir = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, '.basefs')
mount_info = utils.get_mount_info()

defaults = utils.AttrDict(**{
    'dir': basefs_dir,
    'config': os.path.join(basefs_dir, 'config.ini'),
    'keypath': os.path.join(basefs_dir, 'id_ec'),
    'logdir': os.path.join(basefs_dir, 'logs'),
    'hostname': "%s-%s" % (str(uuid.uuid1()).split('-')[-1], socket.gethostname()),
})


def get_port(name):
    return 10000 + int(hashlib.md5(name.encode()).hexdigest(), 16) % (10**4)

# TODO inspect directory before configuration
def get_or_create_config(defaults):
    config = configparser.ConfigParser()
    def save(config=config, defaults=defaults):
        with open(defaults.config, 'w') as configfile:
           config.write(configfile)
    config.save = save
    if not os.path.exists(defaults.config):
        config_dir = os.path.dirname(defaults.config)
        if not os.path.exists(config_dir):
            os.mkdir(config_dir)
        config['DEFAULT'] = {
            '; block_receiving_buffer': 4096,
            '; block_receiving_timeout': 10,
            '; full_sync_interval': 30,
            '; max_block_messages': 15,
            'hostname': defaults.hostname,
        }
        config.save()
    else:
        config.read(defaults.config)
    return config


def send_command(cmd, *args, port=None):
    if not port:
        raise ValueError("Missing port value")
    data = ''
    for part in utils.netcat('127.0.0.1', port, ' '.join(('c' + cmd,) + args).encode()):
        data += part
    if not data:
        sys.stderr.write("No data received from 127.0.0.1:%i\n" % port)
    return data


def create_logdir(logpath, default_logpath, force=False):
    logdir = os.path.dirname(logpath)
    if not os.path.exists(logdir):
        if logpath == default_logpath:
            os.mkdir(logdir)
        else:
            sys.stderr.write("Error: %s logdir directory doesn't exist, create it first.\n" % logdir)
            sys.exit(2)
    if os.path.exists(logpath):
        if not force:
            sys.stderr.write("Error: logpath %s already exists and --force argument was not provided\n" % logpath)
            sys.exit(1)
        else:
            os.remove(logpath)


def run_processes(config, view, script, ip=None, port=None, hostname=None, join=None):
    """ threads should start here, otherwise will not run when fuse is backgrounded """
    handler_kwargs = {}
    serf = None
    serf_agent = None
    handler = None
    if ip and port and hostname:
        serf_agent = gossip.run_agent(ip, port, hostname)
        try:
            serf = gossip.run_client(view, port+1, join or [], config=config)
            loop.run_loop(view, serf, port+2, config=config)
            handler_kwargs = {
                'state': serf.blockstate,
            }
        except:
            serf_agent.stop()
            raise
    if script:
        handler = handlers.Handler(script, view.log, **handler_kwargs)
    return serf, serf_agent, handler
    

def genkey():
    # genkey [<keypath>] [-f]
    genkey_parser.add_argument('keypath', nargs='?',
        default=defaults.keypath,
        help='Path to the EC private key. %s by default.' % defaults.keypath)
    genkey_parser.add_argument('-f', '--force', dest='force', action='store_true',
        help='Rewrite key file if present.')
    args = genkey_parser.parse_args()
    keypath = args.keypath
    keydir = os.path.dirname(keypath)
    if not os.path.exists(keydir):
        if keypath == defaults.keypath:
            os.mkdir(keydir)
        else:
            sys.stderr.write("Error: %s keypath directory doesn't exist, create it first.\n" % keydir)
            sys.exit(2)
    elif not args.force and os.path.exists(keypath):
        sys.stderr.write('Error: %s key already exists, use --force to override it.\n' % keypath)
        sys.exit(2)
    key = Key.generate()
    key.save(keypath)
    config = get_or_create_config(defaults)
    if 'keypath' not in config['DEFAULT']:
        config['DEFAULT']['keypath'] = keypath
        config.save()
    sys.stdout.write("Generate EC key on %s\n" % keypath)
    sys.exit()


def bootstrap():
    # bootsrap <name> -i <ip>[:<port>] [-l <logpath>] [-k <keypath>] [-f]
    bootstrap_parser.add_argument('name',
        help='Name')
    bootstrap_parser.add_argument('-i', '--ips', dest='ips', required=True,
        help='Comma separated ip[:<port>] used as boostrapping nodes.')
    bootstrap_parser.add_argument('-p', '--port', dest='port',
        help='Default port.')
    bootstrap_parser.add_argument('-l', '--logpath',
        help='Path to the basefs log file')
    bootstrap_parser.add_argument('-k', '--keys', dest='keypaths',
        default=defaults.keypath,
        help='Comma separated list of paths containing the root keys. %s by default.' % defaults.keypath)
    bootstrap_parser.add_argument('-f', '--force', dest='force', action='store_true',
        help='Rewrite log file if present')
    
    args = bootstrap_parser.parse_args()
    default_logpath = os.path.join(basefs_dir, 'logs', args.name)
    logpath = args.logpath or default_logpath
    port = args.port or get_port(args.name)
    create_logdir(logpath, default_logpath, args.force)
    keys = []
    for keypath in args.keypaths.split(','):
        if not os.path.isfile(keypath):
            sys.stderr.write("Error: bootsraping keypath %s does not exist.\n" % keypath)
            sys.exit(2)
        keys.append(Key.load(keypath))
    log = Log(logpath) # TODO, name=args.name)
    ips = []
    for ip in args.ips.split(','):
        if ':' not in ip:
            ip += ':%i' % port
        ips.append(ip)
    log.bootstrap(keys, ips)
    config = get_or_create_config(defaults)
    if args.name not in config:
        config[args.name] = {}
    config[args.name].update({
        'logpath': logpath,
        'port': str(port),
    })
    config.save()
    sys.stdout.write('Created log file %s\n' % logpath)
    sys.stdout.write('Network bootstraping will happen at:\n  %s\n' % '\n  '.join(ips))
    sys.exit(0)


def set_run_parser(parser):
    # TODO make validators.name_or_logpath return (name, logpath) tuple for DRY-ines
    parser.add_argument('logpath',
        type=validators.name_or_logpath(parser, get_or_create_config(defaults), defaults),
        help='Log name or logpath')
    parser.add_argument('-k', '--keys', dest='keypath',
        default=defaults.keypath,
        help='Path to the EC private key. %s by default. Use genkey for creating one.' % defaults.keypath,
        type=validators.file_exists(parser, name='keypath'))
    parser.add_argument('-j', '--join', dest='join',
        help='comma separated ip:port used as boostrapping nodes.')
    parser.add_argument('-b', '--bind', dest='bind', default='0.0.0.0',
        help='Basefs bind including: serf agent, serf client (port+1) and basefs server(port+2)')
    parser.add_argument('-iface', dest='iface',
        help='Network interface to bind to. Can be used instead of -bind if the interface is known '
             'but not the address.')
    parser.add_argument('-H', '--hostname', dest='hostname',
        help='Name of this node. Must be unique in the cluster.')
    parser.add_argument('-d', '--debug', dest='debug', action='store_true',
        help='Enables debugging information.')
    parser.add_argument('-s', '--single-node', dest='serf', action='store_false',
        help='Disables Serf agent (testing purposes).')
    parser.add_argument('-w', '--watcher', dest='watcher',
        help='Handler script executed when a change occur on the filesystem (inotify substitute).')


def run(mount=False, parser=None):
    if parser is None:
        set_run_parser(run_parser)
        parser = run_parser
    args = parser.parse_args()
    ip, *port = args.bind.split(':')
    if port:
        port = int(port[0])
    if args.iface:
        iface_ip = utils.get_ip_address(args.iface)
        if ip != '0.0.0.0' and ip != iface_ip:
            sys.stderr.write("-bind and -iface ip addresses do not match %s != %s\n" % (ip, iface_ip))
            sys.exit(9)
        ip = iface_ip
    logpath = args.logpath
    config = get_or_create_config(defaults)
    section = None
    hostname = args.hostname
    if logpath in config:
        section = config[args.logpath]
        logpath = section['logpath']
        if not port:
            port = int(section['port'])
        if not hostname:
            hostname = section.get('hostname', '')
    elif not os.path.exists(logpath) and os.path.exists(os.path.join(defaults.logdir, logpath)):
        if not port:
            port = get_port(logpath)
        logpath = os.path.join(defaults.logdir, logpath)
    elif not port:
        port = 7372
    if not hostname:
        hostname = defaults.hostname
    rpc_port = port+1
    sync_port = port+2
    logpath = os.path.normpath(logpath)
    info, point = utils.get_mountpoint(logpath)
    if info:
        sys.stderr.write("Error: log %s already mounted in %s\n" % (logpath, point))
        sys.exit(4)
    keypath = os.path.normpath(args.keypath)
    logging.basicConfig(
        level=logging.DEBUG if args.debug else logging.INFO,
        format='%(asctime)-15s [%(levelname)s] %(name)s: %(message)s',
    )
    logpath = os.path.normpath(logpath)
    log = Log(logpath)
    log.load()
    if keypath == defaults.keypath and not os.path.exists(keypath):
        view = View(log)
    else:
        key = Key.load(keypath)
        view = View(log, key)
    view.build()
    watcher = None
    if args.serf:
        join = args.join.split(',') if args.join else []
        port, hostname, 
        init_function = functools.partial(run_processes, section, view, args.watcher, ip, port, hostname, join)
    else:
        init_function = functools.partial(run_processes, section, view, args.watcher)
    if mount:
        mountpoint = args.mountpoint
        sys.stdout.write('Mounting %s into %s\n' % (logpath, mountpoint))
        fs = FileSystem(view, init_function=init_function)
        fsname = '%s:%i' % (logpath, sync_port)
        FUSE(fs, mountpoint, fsname=fsname, nothreads=False, foreground=args.debug)
    else:
        serf, serf_agent, __ = init_function()
        try:
            os.wait()
        except KeyboardInterrupt:
            pass
        finally:
            serf_agent.stop()

def mount():
    # mount <name/logpath> <mountpoint> [-b <ip>[:<port>]] [-i <ip>[:<port>]] [-l <logpath>] [-k <keypath/keyname>] [-H <hostname>] [-d]
    set_run_parser(mount_parser)
    mount_parser.add_argument('mountpoint',
        type=validators.dir_exists(mount_parser, name='mountpoint'))
    run(mount=True, parser=mount_parser)


def keys():
    keys_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=validators.file_exists(keys_parser, name='logpath'))
    keys_parser.add_argument('-p', '--path', dest='path', default='/',
        help='Base path.')
    keys_parser.add_argument('-d', '--by-dir', dest='by_dir', action='store_true',
        help='List keys by dir instead of by key.')
    args = keys_parser.parse_args()
    log = Log(args.logpath)
    log.load()
    view = View(log)
    view.build()
    keys = view.get_keys(path=args.path, by_dir=args.by_dir)
    for key, values in keys.items():
        sys.stdout.write(key + '\n')
        for value in values:
            sys.stdout.write('    ' + value + '\n')


def list_cmd():
    config = get_or_create_config(defaults)
    data = [
        ['Name', 'Logpath', 'Def. port', 'Moutpoint', 'Members', 'Logsize', 'Last update'],
        ['----', '-------', '---------', '---------', '-------', '-------', '-----------'],
    ]
    def get_info(logpath):
        statinfo = os.stat(logpath)
        size = utils.sizeof_fmt(statinfo.st_size)
        mtime = datetime.datetime.fromtimestamp(statinfo.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
        minfo, mpoint = utils.get_mountpoint(logpath)
        members = '-'
        if minfo:
            mport = int(minfo.split(':')[1])
            if mport != port:
                mpoint += ':%i' % mport
            members = str(len(send_command('MEMBERS', port=mport).splitlines()))
        else:
            mpoint = 'Not mounted'
        return mpoint, members, size, mtime
    names = []
    for section, content in config.items():
        if section != 'DEFAULT':
            names.append(section)
            logpath = content['logpath']
            port = content['port']
            mpoint, members, size, mtime = get_info(logpath)
            data.append([section, logpath, port, mpoint, members, size, mtime])
    for log in os.listdir(defaults.logdir):
        if log not in names:
            name = log
            logpath = os.path.join(defaults.logdir, log)
            port = str(get_port(name))
            mpoint, members, size, mtime = get_info(logpath)
            data.append([name, logpath, port, mpoint, members, size, mtime])
    sys.stdout.write(utils.tabluate(data) + '\n')


def show():
    show_parser.add_argument('logpath',
        type=validators.name_or_logpath(mount_parser, get_or_create_config(defaults), defaults),
        help='Log name or logpath')
    show_parser.add_argument('path', nargs='?', default=os.sep,
        help='Path to the basefs log file, uses / by default.')
    show_parser.add_argument('-a', '--ascii', dest='ascii', action='store_true',
        help='use ASCII line drawing characters')
    show_parser.add_argument('-c', '--color', dest='color', action='store_true',
        help='use terminal coloring')
    args = show_parser.parse_args()
    config = get_or_create_config(defaults)
    logpath = args.logpath
    if logpath in config:
        logpath = config[args.logpath]['logpath']
    elif not os.path.exists(logpath) and os.path.exists(os.path.join(defaults.logdir, logpath)):
        logpath = os.path.join(defaults.logdir, logpath)
    log = Log(logpath)
    log.load()
    view = View(log)
    view.build()
    
    printed = False
    def print_tree(entry):
        tree = log.print_tree(entry=entry, view=view, color=args.color, ascii=args.ascii)
        if args.ascii:
            sys.stdout.buffer.write(tree.encode('ascii', errors='replace'))
        else:
            sys.stdout.write(tree)
        return True
    
    if mount_info:
        path = os.path.abspath(args.path)
        path = path.replace(mount_info.mountpoint, '')
        entry = log.find(path)
        if entry is None:
            entry = log.find(args.path)
        if entry:
            printed = print_tree(entry)
    else:
        entry = log.find(args.path)
        if entry:
            printed = print_tree(entry)
    if not printed:
        sys.stderr.write("Error: '%s' path does not exist on the log.\n" % args.path)
        sys.exit(2)


def grant():
    # grant <keypath/keyoneliner/keyfingerprint/keyname> <fspath>
#    grant_parser.add_argument('logpath', nargs='?', default=default_logpath,
#        help='Path to the basefs log file, uses %s by default.' % default_logpath,
#        type=lambda v: file_exists(grant_parser, v, name='logpath'))
    grant_parser.add_argument('grantpath',
        help='Path where the permission should be granted.')
    grant_parser.add_argument('grantkey',
        help='Key fingerprint, if exists on lskeys, or path to a public key.',
        type=validators.key(grant_parser))
#    grant_parser.add_argument('-k', '--key', dest='key',
#        default=default_keypath,
#        help='Path to your EC private key. %s by default.' % default_keypath,
#        type=lambda v: key(grant_parser, v))
    args = grant_parser.parse_args()
    mount_info = utils.get_mount_info(os.path.abspath(args.grantpath))
    if mount_info is None:
        sys.stderr.write("Error: grantpath '%s' is not a basefs mountpoint subdir\n" % args.grantpath)
        sys.exit(2)
    path = os.path.relpath(args.grantpath, mount_info.mountpoint)
    if path.startswith('.'):
        path = path[1:]
    path = '/' + path
    context = {
        'path': path,
        'grant_key': args.grantkey.oneliner(),
    }
    grant_cmd = 'c GRANT %(path)s %(grant_key)s' % context
    response = utils.netcat('127.0.0.1', mount_info.port, grant_cmd)
    sys.stdout.write(response)
    sys.exit()


def revoke():
    # revoke <keyfinger/keyname> <fspath>
#    revoke_parser.add_argument('logpath', nargs='?', default=default_logpath,
#        help='Path to the basefs log file, uses %s by default.' % default_logpath,
#        type=lambda v: file_exists(revoke_parser, v, name='logpath'))
    grant_parser.add_argument('revokekey',
        help='Key fingerprint, if exists on lskeys, or path to a public key.',
        type=validators.fingerprint(revoke_parser))
    revoke_parser.add_argument('revokepath', nargs='?', default='/',
        help='Path where the permission should be granted. Defaults to /.')
#    grant_parser.add_argument('-k', '--key', dest='key',
#        default=default_keypath,
#        help='Path to your EC private key. %s by default.' % default_keypath,
#        type=lambda v: key(revoke_parser, v))
    args = revoke_parser.parse_args()
    log = Log(args.logpath)
    view = View(log, args.key)
    view.revoke(args.revokepath, args.revokekey.fingerprint)
    sys.exit()


def revert():
#    revert_parser.add_argument('logpath', nargs='?', default=default_logpath,
#        help='Path to the basefs log file, uses %s by default.' % default_logpath,
#        type=lambda v: file_exists(revoke_parser, v, name='logpath'))
    revert_parser.add_argument('path',
        help='Path of the directory or file to revert')
    revert_parser.add_argument('hash',
        help="Hash of a previous revision, use 'basefs log path' for showing all revisions")
#    revert_parser.add_argument('-k', '--key', dest='key',
#        default=default_keypath,
#        help='Path to your EC private key. %s by default.' % default_keypath,
#        type=lambda v: key(revoke_parser, v))
    args = revert_parser.parse_args()
    log = Log(args.logpath)
    view = View(log, args.key)
    view.revert(args.path, args.hash)
    sys.exit()


def get_cmd_port(args, mount_info, defaults):
    port = mount_info.port if mount_info else None
    print('zero', port)
    if not port and not args.name:
        sys.stderr.write("Error: name should be provided when not running inside a mounted basefs filesystem\n")
        sys.exit(3)
    elif not port:
        config = get_or_create_config(defaults)
        if args.name not in config:
            logpath = os.path.join(defaults.logdir, args.name)
            if os.path.exists(logpath):
                info, __ = utils.get_mountpoint(logpath)
                if info:
                    port = int(info.split(':')[1])
                    print('first', port)
                else:
                    port = get_port(args.name)+2
                    print('second', port)
            else:
                sys.stderr.write("Error: unknwon logname %s\n" % args.name)
                sys.exit(2)
        else:
            port = int(config[args.name].get('port', get_port(args.name)))+2
            print('last', port)
    return port


def blocks():
    blocks_parser.add_argument('name', nargs='?', help='Name')
    args = blocks_parser.parse_args()
    port = get_cmd_port(args, mount_info, defaults)
    while True:
        result = send_command('BLOCKSTATE', port=port)
        sys.stdout.write(result + '\n')
        time.sleep(1)
    sys.exit()


def members():
    members_parser.add_argument('name', nargs='?', help='Name')
    args = members_parser.parse_args()
    port = get_cmd_port(args, mount_info, defaults)
    members = send_command('MEMBERS', port=port)
    sys.stdout.write(members + '\n')
    sys.exit()


def serf():
    serf_parser.add_argument('name', help='Name')
    serf_parser.add_argument('cmd', help='Serf command')
    serf_parser.add_argument('args', metavar='N', nargs='*', help='Serf command arguments')
    args = serf_parser.parse_args()
    cmd_port = get_cmd_port(args, mount_info, defaults)
    if args.cmd in ('state',):
        result = send_command('SERF'+args.cmd.upper(), port=cmd_port)
        sys.stdout.write(result + '\n')
    else:
        rpc_port = cmd_port-1
        os.system('serf %s --rpc-addr=127.0.0.1:%i "%s"' % (args.cmd, rpc_port, ' '.join(args.args)))


def get():
    # get <domainTXT/domain:port/ip:port> [-l <logpath>] [-n <name>] [-p] [-f] [-d]
    bootstrap_parser.add_argument('name')
    bootstrap_parser.add_argument('addr',
        help='ip[:port] or domain name')
    bootstrap_parser.add_argument('-l', '--logpath', dest='logpath',
        help='Path to the basefs log file, use - for stdout.')
    bootstrap_parser.add_argument('-f', '--force', dest='force', action='store_true',
        help='Rewrite log file if present')
    
    args = bootstrap_parser.parse_args()
    default_logpath = os.path.join(basefs_dir, 'logs', args.name)
    logpath = args.logpath or default_logpath
    if logpath != '-':
        create_logdir(logpath, default_logpath, args.force)
    ip, *port = args.addr.split(':')
    try:
        ip = str(ipaddress.ip_address(ip))
    except ValueError:
        nslookup = """nslookup -q=txt %s|grep 'text =' | sed -E 's/.*text = "([^"]+)".*/\\1/'""" % ip
        lookup = subprocess.Popen(nslookup, shell=True, stdout=subprocess.PIPE)
        lookup = lookup.stdout.read().decode().strip()
        if lookup:
            ip, *port = lookup.split(':')
        else:
            nslookup = "nslookup %s -q=a | grep Address|tail -n1 | awk {'print $2'}" % ip
            lookup = subprocess.Popen(nslookup, shell=True, stdout=subprocess.PIPE)
            lookup = lookup.stdout.read().decode().strip()
            if not '#' in lookup:
                ip = lookup
    if not port:
        port = get_port(args.name) + 2
    else:
        port = int(port[0])
    sys.stderr.write("Connecting to %s:%i\n" % (ip, port))
    received = False
    if logpath == '-':
        for data in utils.netcat(ip, port, b'cGET'):
            sys.stdout.write(data)
            received = True
    else:
        try:
            with open(logpath, 'w') as handler:
                for data in utils.netcat(ip, port, b'cGET'):
                    handler.write(data)
                    received = True
        except ConnectionRefusedError:
            os.remove(logpath)
            sys.stderr.write("Error: connection refused, bad port?\n")
            sys.exit(3)
    if not received:
        sys.stderr.write("Error: nothing has been received, bad port?\n")
        sys.exit(2)
    elif logpath != '-':
        log = Log(logpath)
        try:
            log.load(validate=True)
        except exceptions.ValidationError as e:
            sys.stderr.write(str(e) + '\n')
        sys.stdout.write("%s log created\n" % logpath)


def installserf():
    installserf_parser.add_argument('binpath', nargs='?', default='/usr/local/bin/',
        type=validators.dir_exists(installserf, name='binpath'),
        help='Binpath for installing serf, defaults to /usr/local/bin/')
    architectures = {
        'x86_64': 'amd64',
        'AMD64': 'amd64',
        'i686': '386',
        'i586': '386',
        'i386': '386',
        'x86': '386',
    }
    args = installserf_parser.parse_args()
    arch = architectures[platform.machine()]
    url = "https://releases.hashicorp.com/serf/0.6.4/serf_0.6.4_linux_%s.zip" % arch
    sys.stdout.write("Donwloading %s ...\n" % url)
    path, headers = urllib.request.urlretrieve(url)
    try:
        serf_path = os.path.join(args.binpath, 'serf')
        sys.stdout.write("Unpacking into %s ...\n" % serf_path)
        if os.path.exists(serf_path):
            os.remove(serf_path)
        zip_ref = zipfile.ZipFile(path, 'r')
        zip_ref.extractall(args.binpath)
        zip_ref.close()
        st = os.stat(serf_path)
        sys.stdout.write("changing mode of %s to 775\n" % serf_path)
        os.chmod(serf_path, st.st_mode | 0o0111)
    finally:
        os.remove(path)


def help():
    commands = []
    max_key = 0
    for key in methods.keys():
        max_key = max(len(key), max_key)
    tabs = int((max_key+4)/8)
    for key, value in methods.items():
        method, parser = value
        head = '    ' + key
        indent = '\t'*(tabs - int(len(head)/8) + 1)
        commands.append(head + (indent + parser.description if parser else ''))
    sys.stdout.write(textwrap.dedent("""\
        Usage: basefs COMMAND [arg...]
               basefs [ --help | -v | --version ]
        
        Basically Available, Soft state, Eventually consistent File System.
        
        Commands:
        %s
        
        Run 'basefs COMMAND --help' for more information on a command
        """) % '\n'.join(commands))
    sys.exit()


genkey_parser = argparse.ArgumentParser(
    description='Generate a new EC private key',
    prog='basefs genkey')
bootstrap_parser = argparse.ArgumentParser(
    description='Create a new self-contained filesystem',
    prog='basefs bootstrap')
mount_parser = argparse.ArgumentParser(
    description='Mount an existing filesystem',
    prog='basefs mount')
run_parser = argparse.ArgumentParser(
    description='Run an existing filesystem without mounting it (testing)',
    prog='basefs run')
keys_parser = argparse.ArgumentParser(
    description='List keys and their directories',
    prog='basefs keys')
list_parser = argparse.ArgumentParser(
    description='List all available logs',
    prog='basefs list')
show_parser = argparse.ArgumentParser(
    description='Show a log file using a tree representation',
    prog='basefs show')
grant_parser = argparse.ArgumentParser(
    description='Grant key write permission',
    prog='basefs grant')
revoke_parser = argparse.ArgumentParser(
    description='Revoke key write permission',
    prog='basefs revoke')
revert_parser = argparse.ArgumentParser(
    description="Revert object to previous state, 'log' command lists all revisions",
    prog='basefs revert')
blocks_parser = argparse.ArgumentParser(
    description="Block state",
    prog='basefs blocks')
members_parser = argparse.ArgumentParser(
    description="List cluster members",
    prog='basefs members')
serf_parser = argparse.ArgumentParser(
    description="Serf RPC Command proxy",
    prog='basefs serf'
)
get_parser = argparse.ArgumentParser(
    description="Get log from peer address",
    prog='basefs get')
installserf_parser = argparse.ArgumentParser(
    description="Download and install Serf",
    prog='basefs installserf')


methods = OrderedDict([
    ('mount', (mount, mount_parser)),
    ('run', (run, run_parser)),
    ('bootstrap', (bootstrap, bootstrap_parser)),
    ('genkey', (genkey, genkey_parser)),
    ('keys', (keys, keys_parser)),
    ('grant', (grant, grant_parser)),
    ('revoke', (revoke, revoke_parser)),
    ('list', (list_cmd, list_parser)),
    ('show', (show, show_parser)),
    ('revert', (revert, revert_parser)),
    ('blocks', (blocks, blocks_parser)),
    ('members', (members, members_parser)),
    ('serf', (serf, serf_parser)),
    ('get', (get, get_parser)),
    ('installserf', (installserf, installserf_parser)),
    ('help', (help, None)),
])


if __name__ == '__main__':
    if len(sys.argv) > 1:
        method = sys.argv.pop(1)
        if method == '--help':
            method = 'help'
        try:
            method = methods[method][0]
        except KeyError:
            sys.stdout.write("Error: not recognized argument %s\n" % method)
            help()
            sys.exit(1)
    else:
        help()
        sys.exit(1)
    method()
