#!/usr/bin/env python3

import argparse
import atexit
import ipaddress
import os
import pwd
import subprocess
import sys
import textwrap
from collections import OrderedDict

from fuse import FUSE

from basefs import handlers, utils
from basefs.fs import FileSystem
from basefs.keys import Key
from basefs.logs import Log
from basefs.messages import SerfClient
from basefs.views import View


default_keypath = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, '.basefs', 'id_ec')
default_logpath = utils.get_mounted_logpath() or os.path.join(pwd.getpwuid(os.getuid()).pw_dir, '.basefs', 'log')


def file_exists(parser, arg, name='The', exec=None):
    if not os.path.exists(arg):
        parser.error("%s file %s does not exist" % (name, arg))
    elif not os.path.isfile(arg):
        parser.error("%s path %s is not a file" % (name, arg))
    elif exec is True and not os.access(handler, os.X_OK):
        parser.error("%s %s has no execution permissions\n" % (name, arg))
    else:
        return arg


def dir_exists(parser, arg, name='The'):
    if not os.path.exists(arg):
        parser.error("%s dir %s does not exist" % (name, arg))
    elif not os.path.isdir(arg):
        parser.error("%s path %s is not a directory" % (name, arg))
    else:
        return arg


def fingerprint(parser, arg):
    if arg.count(':') != 15:
        parser.error("%s %s not a valid fingerprint" % (name, arg))
    else:
        try:
            return log.keys[args.grant_key]
        except KeyError:
            parser.error("%s %s fingerprint not found." % (name, arg))


def key(parser, arg):
    if file_exists(parser, arg, name='keypath'):
        try:
            return Key.load(arg)
        except Exception as exc:
            parser.error("%s '%s' %s\n" % (name, arg, str(exc)))
    elif arg.count(':') == 15:
        return fingerprint(parser, arg)
    parser.error("%s %s not a valid key fingerprint nor key path." % (name, arg))


mount_parser = argparse.ArgumentParser(
    description='Mount an existing filesystem',
    prog='basefs mount')

def mount():
    mount_parser.add_argument('logpath', nargs='?', default=default_logpath,
        type=lambda v: file_exists(mount_parser, v, name='logpath'))
    mount_parser.add_argument('mountpoint',
        type=lambda v: dir_exists(mount_parser, v, name='mountpoint'))
    mount_parser.add_argument('-k', '--keys', dest='keypath',
        default=default_keypath,
        help='Path to the EC private key. %s by default. Use genkey for creating one.' % default_keypath,
        type=lambda v: file_exists(mount_parser, v, name='keypath'))
    mount_parser.add_argument('--fs-handler', dest='handler', nargs=1,
        help='Custom handler script for filesystem update notifications')
    mount_parser.add_argument('-d', '--debug', dest='debug', action='store_true',
        help='Enables debugging information.')
    mount_parser.add_argument('-n', '--no-serf', dest='serf', action='store_false',
        help='Disables Serf agent (testing purposes).')
    
    args = mount_parser.parse_args()
    logpath = os.path.normpath(args.logpath)
    keypath = os.path.normpath(args.keypath)
    mountpoint = args.mountpoint
    if args.serf:
        context = {
            'script': os.path.realpath(__file__),
            'log': logpath,
            'handler': ('--fs-handler='+args.handler[0]) if args.handler else '',
            'debug': '-log-level=debug' if args.debug else ''
        }
        cmd = "serf agent -replay %(debug)s -event-handler='%(script)s handler %(log)s %(handler)s'" % context
        sys.stdout.write(cmd + '\n')
        import threading
        serf_agent = threading.Thread(target=os.system, args=(cmd,))
        serf_agent.start()
#        serf_agent = subprocess.Popen(cmd, shell=True)
#        atexit.register(lambda: serf_agent.kill())
    sys.stdout.write('Monting %s into %s\n' % (logpath, mountpoint))
    FUSE(FileSystem(logpath, keypath), mountpoint, fsname=logpath, nothreads=True, foreground=True)


bootstrap_parser = argparse.ArgumentParser(
    description='Create a new self-contained filesystem',
    prog='basefs bootstrap')

def bootstrap():
    bootstrap_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath)
    bootstrap_parser.add_argument('-k', '--keys', dest='keypaths',
        default=default_keypath,
        help='Comma separated list of paths containing the root keys. %s by default.' % default_keypath)
    bootstrap_parser.add_argument('-i', '--ips', dest='ips', required=True,
        help='comma separated ips used as boostrapping nodes.')
    bootstrap_parser.add_argument('-f', '--force', dest='force', action='store_true',
        help='Rewrite log file if present')
    
    args = bootstrap_parser.parse_args()
    logpath = args.logpath
    if os.path.exists(logpath):
        if not args.force:
            sys.stderr.write("Error: logpath %s already exists and --force argument was not provided\n" % logpath)
            sys.exit(1)
        else:
            os.remove(logpath)
    keys = []
    for keypath in args.keypaths.split(','):
        if not os.path.isfile(keypath):
            sys.stderr.write("Error: bootsraping keypath %s does not exist.\n" % keypath)
            sys.exit(2)
        keys.append(Key.load(keypath))
    ips = [str(ipaddress.ip_address(ip)) for ip in args.ips.split(',')]
    log = Log(logpath)
    log.bootstrap(keys, ips)
    sys.stdout.write('Created log file %s\n' % logpath)
    sys.exit(0)


handler_parser = argparse.ArgumentParser(
    description='Run as Serf handler',
    prog='basefs handler')

def handler():
    handler_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=lambda v: file_exists(handler_parser, v, name='logpath'))
    handler_parser.add_argument('--fs-handler', dest='handler', nargs=1,
        help='custom handler, used for executing custom actions when a path is updated.',
        type=lambda v: file_exists(handler_parser, v, name='fs handler', exec=True))
    args = handler_parser.parse_args()
    handler = args.handler[0] if args.handler else None
    event = os.environ.get('SERF_EVENT')
    user_event = os.environ.get('SERF_USER_EVENT')
    
    if event == 'user' and user_event == 'logentry':
        log = Log(args.logpath)
        log.load()
        client = SerfClient(log)
        client.receive(sys.stdin.buffer.read())
    sys.exit()


genkey_parser = argparse.ArgumentParser(
    description='Generate a new EC private key',
    prog='basefs genkey')

def genkey():
    genkey_parser.add_argument('keypath', nargs='?',
        default=default_keypath,
        help='Path to the EC private key. %s by default.' % default_keypath)
    genkey_parser.add_argument('-f', '--force', dest='force', action='store_true',
        help='Rewrite key file if present.')
    args = genkey_parser.parse_args()
    keypath = args.keypath
    keydir = os.path.dirname(keypath)
    if not os.path.exists(keydir):
        if keypath == default_keypath:
            os.mkdir(keydir)
        else:
            sys.stderr.write("Error: %s keypath directory doesn't exist, create it first.\n" % keydir)
            sys.exit(2)
    elif not args.force and os.path.exists(keypath):
        sys.stderr.write('Error: %s key already exists, use --force to override it.\n' % keypath)
        sys.exit(2)
    key = Key.generate()
    key.save(keypath)
    sys.stdout.write("Generate EC key on %s\n" % keypath)
    sys.exit()


lskeys_parser = argparse.ArgumentParser(
    description='List keys and their directories',
    prog='basefs lskeys')

def lskeys():
    lskeys_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=lambda v: file_exists(lskeys_parser, v, name='logpath'))
    lskeys_parser.add_argument('-p', '--path', dest='path', default='/',
        help='Base path.')
    lskeys_parser.add_argument('-d', '--by-dir', dest='by_dir', action='store_true',
        help='List keys by dir instead of by key.')
    args = lskeys_parser.parse_args()
    log = Log(args.logpath)
    log.load()
    view = View(log)
    view.build()
    keys = view.get_keys(path=args.path, by_dir=args.by_dir)
    for key, values in keys.items():
        sys.stdout.write(key + '\n')
        for value in values:
            sys.stdout.write('    ' + value + '\n')


logtree_parser = argparse.ArgumentParser(
    description='Show a log file using a tree representation',
    prog='basefs logtree')

def logtree():
    logtree_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=lambda v: file_exists(logtree_parser, v, name='logpath'))
    logtree_parser.add_argument('-a', '--ascii', dest='ascii', action='store_true',
        help='use ASCII line drawing characters')
    logtree_parser.add_argument('-c', '--color', dest='color', action='store_true',
        help='use terminal coloring')
    args = logtree_parser.parse_args()
    log = Log(args.logpath)
    log.load()
    view = View(log)
    view.build()
    tree = log.print_tree(view=view, color=args.color, ascii=args.ascii)
    if args.ascii:
        sys.stdout.buffer.write(tree.encode('ascii', errors='replace'))
    else:
        sys.stdout.write(tree)


grant_parser = argparse.ArgumentParser(
    description='Grant key write permission',
    prog='basefs grant')

#def grant():
#    grant_parser.add_argument('logpath', nargs='?', default=default_logpath,
#        help='Path to the basefs log file, uses %s by default.' % default_logpath,
#        type=lambda v: file_exists(grant_parser, v, name='logpath'))
#    grant_parser.add_argument('grantkey',
#        help='Key fingerprint, if exists on lskeys, or path to a public key.',
#        type=lambda v: key(grant_parser, v))
#    grant_parser.add_argument('grantpath',
#        help='Path where the permission should be granted.')
#    grant_parser.add_argument('-k', '--key', dest='key',
#        default=default_keypath,
#        help='Path to your EC private key. %s by default.' % default_keypath,
#        type=lambda v: key(grant_parser, v))
#    args = grant_parser.parse_args()
#    log = Log(args.logpath)
#    view = View(log, args.key)
#    view.grant(args.grant_path, args.grantkey)
#    sys.exit()


#revoke_parser = argparse.ArgumentParser(
#    description='Revoke key write permission',
#    prog='basefs revoke')

#def revoke():
#    revoke_parser.add_argument('logpath', nargs='?', default=default_logpath,
#        help='Path to the basefs log file, uses %s by default.' % default_logpath,
#        type=lambda v: file_exists(revoke_parser, v, name='logpath'))
#    grant_parser.add_argument('revokekey',
#        help='Key fingerprint, if exists on lskeys, or path to a public key.',
#        type=lambda v: fingerprint(revoke_parser, v))
#    revoke_parser.add_argument('revokepath', nargs='?', default='/',
#        help='Path where the permission should be granted. Defaults to /.')
#    grant_parser.add_argument('-k', '--key', dest='key',
#        default=default_keypath,
#        help='Path to your EC private key. %s by default.' % default_keypath,
#        type=lambda v: key(revoke_parser, v))
#    args = revoke_parser.parse_args()
#    log = Log(args.logpath)
#    view = View(log, args.key)
#    view.revoke(args.revokepath, args.revokekey.fingerprint)
#    sys.exit()



test_parser = argparse.ArgumentParser(
    description='????',
    prog='basefs test')

def test():
    test_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=lambda v: file_exists(test_parser, v, name='logpath'))
    test_parser.add_argument('-p', '--port', dest='port', default=2222, type=int)
    args = test_parser.parse_args()
    handlers.run(args.logpath, args.port)


def help():
    commands = []
    for key, value in methods.items():
        method, parser = value
        commands.append('    '+key + ('\t' + parser.description if parser else ''))
    sys.stdout.write(textwrap.dedent("""\
        Usage: basefs COMMAND [arg...]
               basefs [ --help | -v | --version ]
        
        Basically Available, Soft state, Eventually consistent File System.
        
        Commands:
        %s
        
        Run 'basefs COMMAND --help' for more information on a command
        """) % '\n'.join(commands))
    sys.exit()


methods = OrderedDict([
    ('mount', (mount, mount_parser)),
    ('handler', (handler, handler_parser)),
    ('bootstrap', (bootstrap, bootstrap_parser)),
    ('genkey', (genkey, genkey_parser)),
    ('lskeys', (lskeys, lskeys_parser)),
#    ('grant', (grant, grant_parser)),
#    ('revoke', (revoke, revoke_parser)),
    ('logtree', (logtree, logtree_parser)),
    ('test', (test, test_parser)),
    ('help', (help, None)),
])


if __name__ == '__main__':
    if len(sys.argv) > 1:
        method = sys.argv.pop(1)
        if method == '--help':
            method = 'help'
        try:
            method = methods[method][0]
        except KeyError:
            sys.stdout.write("Error: not recognized argument %s\n" % method)
            help()
            sys.exit(1)
    else:
        help()
        sys.exit(1)
    method()
