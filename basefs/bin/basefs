#!/usr/bin/env python3

import argparse
import atexit
import ipaddress
import os
import pwd
import subprocess
import sys
import textwrap
from collections import OrderedDict

from fuse import FUSE

from basefs.fs import FileSystem
from basefs.keys import Key
from basefs.logs import Log
from basefs.views import View


default_keypath = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, '.basefs', 'id_ec')
default_logpath = os.path.join(pwd.getpwuid(os.getuid()).pw_dir, '.basefs', 'log')


def file_exists(parser, arg, name='The', exec=None):
    if not os.path.exists(arg):
        parser.error("%s file %s does not exist" % (name, arg))
    elif not os.path.isfile(arg):
        parser.error("%s path %s is not a file" % (name, arg))
    elif exec is True and not os.access(handler, os.X_OK):
        parser.error("%s %s has no execution permissions\n" % (name, arg))
    else:
        return arg


def dir_exists(parser, arg, name='The'):
    if not os.path.exists(arg):
        parser.error("%s dir %s does not exist" % (name, arg))
    elif not os.path.isdir(arg):
        parser.error("%s path %s is not a directory" % (name, arg))
    else:
        return arg


mount_parser = argparse.ArgumentParser(
    description='Mount an existing filesystem',
    prog='basefs mount')


def mount():
    mount_parser.add_argument('logpath', nargs='?', default=default_logpath,
        type=lambda v: file_exists(mount_parser, v, name='logpath'))
    mount_parser.add_argument('mountpoint',
        type=lambda v: dir_exists(mount_parser, v, name='mountpoint'))
    mount_parser.add_argument('-k', '--keys', dest='keypath',
        default=default_keypath,
        help='Path to the EC private key. %s by default. Use genkey for creating one.' % default_keypath,
        type=lambda v: file_exists(mount_parser, v, name='keypath'))
    mount_parser.add_argument('--fs-handler', dest='handler', nargs=1,
        help='Custom handler script for filesystem update notifications')
    mount_parser.add_argument('-d', '--debug', dest='debug', action='store_true',
        help='Enables debugging information.')
    mount_parser.add_argument('-n', '--no-serf', dest='serf', action='store_false',
        help='Disables Serf agent (testing purposes).')
    
    args = mount_parser.parse_args()
    logpath = args.logpath
    keypath = args.keypath
    mountpoint = args.mountpoint
    if args.serf:
        context = {
            'script': os.path.realpath(__file__),
            'log': logpath,
            'handler': '--fs-handler'+args.handler[0] if args.handler else '',
            'debug': '--log-level=debug' if args.debug else ''
        }
        cmd = "serf agent --event-handler='%(script)s handler %(log)s %(handler)s' %(debug)s" % context
        sys.stdout.write(cmd + '\n')
        serf_agent = subprocess.Popen(cmd, shell=True)
        atexit.register(lambda: serf_agent.kill())
    sys.stdout.write('Monting %s into %s\n' % (logpath, mountpoint))
    FUSE(FileSystem(logpath, keypath), mountpoint, nothreads=True, foreground=True)


bootstrap_parser = argparse.ArgumentParser(
    description='Create a new self-contained filesystem.',
    prog='basefs bootstrap')


def bootstrap():
    bootstrap_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath)
    bootstrap_parser.add_argument('-k', '--keys', dest='keypaths',
        default=default_keypath,
        help='Comma separated list of paths containing the root keys. %s by default.' % default_keypath)
    bootstrap_parser.add_argument('-i', '--ips', dest='ips', required=True,
        help='comma separated ips used as boostrapping nodes.')
    bootstrap_parser.add_argument('-f', '--force', dest='force', action='store_true',
        help='Rewrite log file if present')
    
    args = bootstrap_parser.parse_args()
    logpath = args.logpath
    if os.path.exists(logpath):
        if not args.force:
            sys.stderr.write("Error: logpath %s already exists and --force argument was not provided\n" % logpath)
            sys.exit(1)
        else:
            os.remove(logpath)
    keys = []
    for keypath in args.keypaths.split(','):
        if not os.path.isfile(keypath):
            sys.stderr.write("Error: bootsraping keypath %s does not exist.\n" % keypath)
            sys.exit(2)
        keys.append(Key.load(keypath))
    ips = [str(ipaddress.ip_address(ip)) for ip in args.ips.split(',')]
    log = Log(logpath)
    log.bootstrap(keys, ips)
    sys.stdout.write('Created log file %s\n' % logpath)
    sys.exit(0)


handler_parser = argparse.ArgumentParser(
    description='Run as Serf handler',
    prog='basefs handler')


def handler():
    handler_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=lambda v: file_exists(handler_parser, v, name='logpath'))
    handler_parser.add_argument('--fs-handler', dest='handler', nargs=1,
        help='custom handler, used for executing custom actions when a path is updated.',
        type=lambda v: file_exists(handler_parser, v, name='fs handler', exec=True))
    args = handler_parser.parse_args()
    handler = args.handler[0] if args.handler else None
    event = os.environ.get('SERF_EVENT')
    user_event = os.environ.get('SERF_USER_EVENT')
    if event == 'user' and user_event == 'logentry':
        # TODO while read line: zlib.decompres(lines)
        line = sys.stdin.readline().strip()
        try:
            entry = LogEntry.read_line(line)
            entry.clean()
        except Exception as err:
            sys.stdout.write("Invalid log entry '%s', %s\n" % (line, err))
            sys.exit(2)
        context = {
            'id': line.split()[0],
            'logpath': args.logpath,
            'line': line,
            'handler': handler,
            'path': entry.path,
        }
        exit_code = os.system("grep '^%(id)s ' %(logpath)s > /dev/null && exit 99 || echo '%(line)s' >> %(logpath)s;" % context)
        if exit_code == 99:
            sys.stdout.write('%(id)s already present\n' % context)
        elif exit_code == 0:
            sys.stdout.write('OK: %(id)s not present\n' % context)
            if args.handler:
                os.system("%(handler)s %(path)s")
        else:
            sys.stdout.write('%(id)s shell error writing to log\n' % context)
    sys.exit()


genkey_parser = argparse.ArgumentParser(
    description='Generate a new EC private key',
    prog='basefs genkey')


def genkey():
    genkey_parser.add_argument('keypath', nargs='?',
        default=default_keypath,
        help='Path to the EC private key. %s by default.' % default_keypath)
    genkey_parser.add_argument('-f', '--force', dest='force', action='store_true',
        help='Rewrite key file if present.')
    args = genkey_parser.parse_args()
    keypath = args.keypath
    keydir = os.path.dirname(keypath)
    if not os.path.exists(keydir):
        if keypath == default_keypath:
            os.mkdir(keydir)
        else:
            sys.stderr.write("Error: %s keypath directory doesn't exist, create it first.\n" % keydir)
            sys.exit(2)
    elif not args.force and os.path.exists(keypath):
        sys.stderr.write('Error: %s key already exists, use --force to override it.\n' % keypath)
        sys.exit(2)
    key = Key.generate()
    key.save(keypath)
    sys.stdout.write("Generate EC key on %s\n" % keypath)
    sys.exit()


lskeys_parser = argparse.ArgumentParser(
    description='List keys and their directories.',
    prog='basefs lskeys')


def lskeys():
    lskeys_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=lambda v: file_exists(lskeys_parser, v, name='logpath'))
    lskeys_parser.add_argument('-p', '--path', dest='path', default='/',
        help='Base path.')
    lskeys_parser.add_argument('-d', '--by-dir', dest='by_dir', action='store_true',
        help='List keys by dir instead of by key.')
    args = lskeys_parser.parse_args()
    log = Log(args.logpath)
    log.load()
    view = View(log)
    view.build()
    keys = view.get_keys(path=args.path, by_dir=args.by_dir)
    for key, values in keys.items():
        sys.stdout.write(key + '\n')
        for value in values:
            sys.stdout.write('    ' + value + '\n')


logtree_parser = argparse.ArgumentParser(
    description='Show a log file using a tree structure.', prog='basefs logtree')


def logtree():
    logtree_parser.add_argument('logpath', nargs='?', default=default_logpath,
        help='Path to the basefs log file, uses %s by default.' % default_logpath,
        type=lambda v: file_exists(logtree_parser, v, name='logpath'))
    logtree_parser.add_argument('-a', '--ascii', dest='ascii', action='store_true',
        help='use ASCII line drawing characters')
    logtree_parser.add_argument('-c', '--color', dest='color', action='store_true',
        help='use terminal coloring')
    args = logtree_parser.parse_args()
    if args.ascii:
        raise NotImplementedError
    log = Log(args.logpath)
    log.load()
    view = View(log)
    view.build()
    sys.stdout.write(log.print_tree(view=view, color=args.color))


def help():
    commands = []
    for key, value in methods.items():
        method, parser = value
        commands.append('    '+key + ('\t' + parser.description if parser else ''))
    sys.stdout.write(textwrap.dedent("""\
        Usage: basefs COMMAND [arg...]
               basefs [ --help | -v | --version ]
        
        Basically Available, Soft state, Eventually consistent File System.
        
        Commands:
        %s
        
        Run 'basefs COMMAND --help' for more information on a command
        """) % '\n'.join(commands))
    sys.exit()


methods = OrderedDict([
    ('mount', (mount, mount_parser)),
    ('handler', (handler, handler_parser)),
    ('bootstrap', (bootstrap, bootstrap_parser)),
    ('genkey', (genkey, genkey_parser)),
    ('lskeys', (lskeys, lskeys_parser)),
    ('logtree', (logtree, logtree_parser)),
    ('help', (help, None)),
])


if __name__ == '__main__':
    if len(sys.argv) > 1:
        method = sys.argv.pop(1)
        if method == '--help':
            method = 'help'
        try:
            method = methods[method][0]
        except KeyError:
            sys.stdout.write("Error: not recognized argument %s\n" % method)
            help()
            sys.exit(1)
    else:
        help()
        sys.exit(1)
    method()
